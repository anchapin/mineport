name: Artifact Security & Compliance

on:
  workflow_call:
    inputs:
      artifact_name:
        description: 'Name of the artifact to secure'
        required: true
        type: string
      version:
        description: 'Version of the artifact'
        required: true
        type: string
      sign_artifacts:
        description: 'Whether to sign artifacts'
        required: false
        default: true
        type: boolean
    secrets:
      GPG_PRIVATE_KEY:
        description: 'GPG private key for signing'
        required: false
      GPG_PASSPHRASE:
        description: 'GPG passphrase'
        required: false
      COSIGN_PRIVATE_KEY:
        description: 'Cosign private key for container signing'
        required: false
      COSIGN_PASSWORD:
        description: 'Cosign password'
        required: false

  workflow_dispatch:
    inputs:
      artifact_name:
        description: 'Name of the artifact to secure'
        required: true
        type: string
      version:
        description: 'Version of the artifact'
        required: true
        type: string
      sign_artifacts:
        description: 'Whether to sign artifacts'
        required: false
        default: true
        type: boolean

env:
  ARTIFACT_NAME: ${{ inputs.artifact_name }}
  VERSION: ${{ inputs.version }}

jobs:
  # Artifact security scanning
  security-scan:
    name: Security Scan Artifacts
    runs-on: ubuntu-latest
    outputs:
      scan_results: ${{ steps.scan.outputs.results }}
      vulnerabilities_found: ${{ steps.scan.outputs.vulnerabilities_found }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: artifacts

      - name: Setup security scanning tools
        run: |
          # Install security scanning tools
          echo "Installing security scanning tools..."
          
          # Install Trivy for vulnerability scanning
          sudo apt-get update
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy
          
          # Install Syft for SBOM generation
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          
          # Install Grype for vulnerability scanning
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Extract and scan artifacts
        id: scan
        run: |
          echo "Scanning artifacts for security vulnerabilities..."
          
          # Create scan results directory
          mkdir -p scan-results
          
          # Initialize scan results
          VULNERABILITIES_FOUND=false
          SCAN_RESULTS=""
          
          # Scan each artifact
          for artifact in artifacts/*; do
            if [[ -f "$artifact" ]]; then
              filename=$(basename "$artifact")
              echo "Scanning $filename..."
              
              # Determine scan type based on file extension
              case "$filename" in
                *.tgz|*.tar.gz)
                  echo "Scanning npm package: $filename"
                  
                  # Extract package for scanning
                  mkdir -p "temp-extract/$filename"
                  tar -xzf "$artifact" -C "temp-extract/$filename"
                  
                  # Scan with Trivy
                  trivy fs --format json --output "scan-results/${filename}-trivy.json" "temp-extract/$filename" || true
                  
                  # Generate SBOM with Syft
                  syft "temp-extract/$filename" -o json > "scan-results/${filename}-sbom.json" || true
                  
                  # Scan with Grype
                  grype "temp-extract/$filename" -o json > "scan-results/${filename}-grype.json" || true
                  
                  # Check for high/critical vulnerabilities
                  if trivy fs --severity HIGH,CRITICAL --quiet "temp-extract/$filename" | grep -q "Total:"; then
                    VULNERABILITIES_FOUND=true
                    echo "âš ï¸ High/Critical vulnerabilities found in $filename"
                  fi
                  
                  # Cleanup
                  rm -rf "temp-extract/$filename"
                  ;;
                  
                *.zip)
                  echo "Scanning zip archive: $filename"
                  
                  # Extract and scan zip
                  mkdir -p "temp-extract/$filename"
                  unzip -q "$artifact" -d "temp-extract/$filename"
                  
                  # Scan with Trivy
                  trivy fs --format json --output "scan-results/${filename}-trivy.json" "temp-extract/$filename" || true
                  
                  # Check for vulnerabilities
                  if trivy fs --severity HIGH,CRITICAL --quiet "temp-extract/$filename" | grep -q "Total:"; then
                    VULNERABILITIES_FOUND=true
                    echo "âš ï¸ High/Critical vulnerabilities found in $filename"
                  fi
                  
                  # Cleanup
                  rm -rf "temp-extract/$filename"
                  ;;
                  
                *.json)
                  echo "Scanning JSON file: $filename"
                  # Basic JSON validation and content scanning
                  if ! jq empty "$artifact" 2>/dev/null; then
                    echo "âš ï¸ Invalid JSON format in $filename"
                  fi
                  ;;
                  
                *)
                  echo "Skipping unknown file type: $filename"
                  ;;
              esac
            fi
          done
          
          # Generate summary report
          cat > scan-results/security-summary.json << EOF
          {
            "scan_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "artifact_name": "${{ env.ARTIFACT_NAME }}",
            "version": "${{ env.VERSION }}",
            "vulnerabilities_found": $VULNERABILITIES_FOUND,
            "scan_tools": ["trivy", "syft", "grype"],
            "scanned_files": $(ls artifacts/ | wc -l)
          }
          EOF
          
          echo "vulnerabilities_found=$VULNERABILITIES_FOUND" >> $GITHUB_OUTPUT
          echo "results=$(cat scan-results/security-summary.json | base64 -w 0)" >> $GITHUB_OUTPUT
          
          if [[ "$VULNERABILITIES_FOUND" == "true" ]]; then
            echo "âŒ Security vulnerabilities found in artifacts"
          else
            echo "âœ… No high/critical vulnerabilities found"
          fi

      - name: Upload security scan results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results-${{ env.VERSION }}
          path: scan-results/
          retention-days: 90

      - name: Fail on critical vulnerabilities
        if: steps.scan.outputs.vulnerabilities_found == 'true'
        run: |
          echo "âŒ Critical security vulnerabilities found in artifacts"
          echo "Please review the security scan results and address the vulnerabilities before proceeding"
          exit 1

  # GPG signing of artifacts
  gpg-signing:
    name: GPG Sign Artifacts
    needs: security-scan
    if: inputs.sign_artifacts == true && secrets.GPG_PRIVATE_KEY != ''
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: artifacts

      - name: Import GPG key
        run: |
          echo "Importing GPG key for signing..."
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d | gpg --batch --import
          
          # List imported keys
          gpg --list-secret-keys

      - name: Sign artifacts
        run: |
          echo "Signing artifacts with GPG..."
          
          # Create signatures directory
          mkdir -p signatures
          
          # Sign each artifact
          for artifact in artifacts/*; do
            if [[ -f "$artifact" ]]; then
              filename=$(basename "$artifact")
              echo "Signing $filename..."
              
              # Create detached signature
              gpg --batch --yes --pinentry-mode loopback \
                  --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
                  --armor --detach-sign \
                  --output "signatures/${filename}.asc" \
                  "$artifact"
              
              # Verify signature
              if gpg --verify "signatures/${filename}.asc" "$artifact"; then
                echo "âœ… Successfully signed and verified $filename"
              else
                echo "âŒ Failed to verify signature for $filename"
                exit 1
              fi
            fi
          done
          
          # Create signature manifest
          cat > signatures/signature-manifest.json << EOF
          {
            "signing_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "artifact_name": "${{ env.ARTIFACT_NAME }}",
            "version": "${{ env.VERSION }}",
            "signer": "$(gpg --list-secret-keys --with-colons | grep '^uid' | head -1 | cut -d: -f10)",
            "key_id": "$(gpg --list-secret-keys --with-colons | grep '^sec' | head -1 | cut -d: -f5)",
            "signatures": [
          EOF
          
          first=true
          for sig in signatures/*.asc; do
            if [[ -f "$sig" ]]; then
              if [[ "$first" == "false" ]]; then
                echo "," >> signatures/signature-manifest.json
              fi
              first=false
              
              filename=$(basename "$sig" .asc)
              echo "      {" >> signatures/signature-manifest.json
              echo "        \"file\": \"$filename\"," >> signatures/signature-manifest.json
              echo "        \"signature\": \"$(basename "$sig")\"" >> signatures/signature-manifest.json
              echo "      }" >> signatures/signature-manifest.json
            fi
          done
          
          cat >> signatures/signature-manifest.json << EOF
            ]
          }
          EOF
          
          echo "Generated signature manifest:"
          cat signatures/signature-manifest.json | jq .

      - name: Upload signed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: signed-artifacts-${{ env.VERSION }}
          path: |
            artifacts/
            signatures/
          retention-days: 365

  # Container image signing with Cosign
  container-signing:
    name: Sign Container Images
    needs: security-scan
    if: inputs.sign_artifacts == true && secrets.COSIGN_PRIVATE_KEY != ''
    runs-on: ubuntu-latest
    
    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Sign container image
        run: |
          echo "Signing container image with Cosign..."
          
          # Import Cosign private key
          echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
          
          # Sign the container image
          IMAGE_URI="ghcr.io/${{ github.repository }}:${{ env.VERSION }}"
          
          cosign sign --key cosign.key \
            --password "${{ secrets.COSIGN_PASSWORD }}" \
            "$IMAGE_URI"
          
          # Verify the signature
          cosign verify --key cosign.pub "$IMAGE_URI"
          
          echo "âœ… Container image signed and verified successfully"
          
          # Cleanup
          rm -f cosign.key

      - name: Generate attestation
        run: |
          echo "Generating SLSA attestation..."
          
          IMAGE_URI="ghcr.io/${{ github.repository }}:${{ env.VERSION }}"
          
          # Create attestation
          cat > attestation.json << EOF
          {
            "_type": "https://in-toto.io/Statement/v0.1",
            "predicateType": "https://slsa.dev/provenance/v0.2",
            "subject": [
              {
                "name": "$IMAGE_URI",
                "digest": {
                  "sha256": "$(docker inspect --format='{{index .RepoDigests 0}}' $IMAGE_URI | cut -d'@' -f2 | cut -d':' -f2)"
                }
              }
            ],
            "predicate": {
              "builder": {
                "id": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              },
              "buildType": "https://github.com/actions/runner",
              "invocation": {
                "configSource": {
                  "uri": "git+https://github.com/${{ github.repository }}@${{ github.sha }}",
                  "digest": {
                    "sha1": "${{ github.sha }}"
                  }
                }
              },
              "metadata": {
                "buildInvocationId": "${{ github.run_id }}",
                "buildStartedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "completeness": {
                  "parameters": true,
                  "environment": false,
                  "materials": false
                },
                "reproducible": false
              }
            }
          }
          EOF
          
          # Sign attestation
          cosign attest --key cosign.key \
            --password "${{ secrets.COSIGN_PASSWORD }}" \
            --predicate attestation.json \
            "$IMAGE_URI"
          
          echo "âœ… SLSA attestation generated and signed"

  # Audit trail logging
  audit-logging:
    name: Audit Trail Logging
    needs: [security-scan, gpg-signing, container-signing]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate comprehensive audit log
        run: |
          echo "Generating audit trail..."
          
          # Create audit log directory
          mkdir -p audit-logs
          
          # Generate comprehensive audit log
          cat > audit-logs/artifact-security-audit.json << EOF
          {
            "audit_version": "1.0",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "artifact": {
              "name": "${{ env.ARTIFACT_NAME }}",
              "version": "${{ env.VERSION }}",
              "repository": "${{ github.repository }}",
              "commit_sha": "${{ github.sha }}",
              "ref": "${{ github.ref }}"
            },
            "workflow": {
              "run_id": "${{ github.run_id }}",
              "run_number": "${{ github.run_number }}",
              "workflow": "${{ github.workflow }}",
              "actor": "${{ github.actor }}",
              "event": "${{ github.event_name }}"
            },
            "security_operations": {
              "vulnerability_scan": {
                "performed": true,
                "status": "${{ needs.security-scan.result }}",
                "vulnerabilities_found": "${{ needs.security-scan.outputs.vulnerabilities_found }}"
              },
              "gpg_signing": {
                "performed": ${{ inputs.sign_artifacts == true && secrets.GPG_PRIVATE_KEY != '' }},
                "status": "${{ needs.gpg-signing.result }}"
              },
              "container_signing": {
                "performed": ${{ inputs.sign_artifacts == true && secrets.COSIGN_PRIVATE_KEY != '' }},
                "status": "${{ needs.container-signing.result }}"
              }
            },
            "compliance": {
              "security_scan_passed": ${{ needs.security-scan.outputs.vulnerabilities_found != 'true' }},
              "artifacts_signed": ${{ inputs.sign_artifacts == true }},
              "audit_trail_complete": true
            }
          }
          EOF
          
          echo "Generated audit log:"
          cat audit-logs/artifact-security-audit.json | jq .
          
          # Create human-readable audit report
          cat > audit-logs/audit-report.md << 'EOF'
          # Artifact Security Audit Report
          
          **Artifact:** ${{ env.ARTIFACT_NAME }} v${{ env.VERSION }}
          **Date:** $(date -u +%Y-%m-%d)
          **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ## Security Operations Performed
          
          | Operation | Status | Result |
          |-----------|--------|--------|
          | Vulnerability Scan | ${{ needs.security-scan.result }} | ${{ needs.security-scan.outputs.vulnerabilities_found == 'true' && 'âš ï¸ Vulnerabilities Found' || 'âœ… No Critical Issues' }} |
          | GPG Signing | ${{ needs.gpg-signing.result || 'Skipped' }} | ${{ needs.gpg-signing.result == 'success' && 'âœ… Signed' || needs.gpg-signing.result == 'failure' && 'âŒ Failed' || 'âž– Not Performed' }} |
          | Container Signing | ${{ needs.container-signing.result || 'Skipped' }} | ${{ needs.container-signing.result == 'success' && 'âœ… Signed' || needs.container-signing.result == 'failure' && 'âŒ Failed' || 'âž– Not Performed' }} |
          
          ## Compliance Status
          
          - **Security Scan**: ${{ needs.security-scan.outputs.vulnerabilities_found != 'true' && 'âœ… Passed' || 'âŒ Failed' }}
          - **Artifact Signing**: ${{ inputs.sign_artifacts == true && 'âœ… Enabled' || 'âš ï¸ Disabled' }}
          - **Audit Trail**: âœ… Complete
          
          ## Recommendations
          
          ${{ needs.security-scan.outputs.vulnerabilities_found == 'true' && '- Address security vulnerabilities before release' || '' }}
          ${{ inputs.sign_artifacts != true && '- Enable artifact signing for production releases' || '' }}
          - Regularly update security scanning tools
          - Monitor for new vulnerabilities in dependencies
          
          EOF
          
          # Replace template variables in markdown
          sed -i "s/\${{ env.ARTIFACT_NAME }}/${{ env.ARTIFACT_NAME }}/g" audit-logs/audit-report.md
          sed -i "s/\${{ env.VERSION }}/${{ env.VERSION }}/g" audit-logs/audit-report.md

      - name: Upload audit logs
        uses: actions/upload-artifact@v4
        with:
          name: audit-logs-${{ env.VERSION }}
          path: audit-logs/
          retention-days: 2555  # 7 years for compliance

      - name: Create audit trail issue
        if: needs.security-scan.outputs.vulnerabilities_found == 'true'
        run: |
          gh issue create \
            --title "ðŸ”’ Security Audit Alert: Vulnerabilities in ${{ env.ARTIFACT_NAME }} v${{ env.VERSION }}" \
            --body-file audit-logs/audit-report.md \
            --label "security,audit,vulnerability" \
            --assignee "${{ github.actor }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Post audit summary
        run: |
          echo "## ðŸ”’ Artifact Security Audit Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Artifact:** ${{ env.ARTIFACT_NAME }} v${{ env.VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Security Scan:** ${{ needs.security-scan.outputs.vulnerabilities_found != 'true' && 'âœ… Passed' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "**GPG Signing:** ${{ needs.gpg-signing.result == 'success' && 'âœ… Completed' || needs.gpg-signing.result == 'failure' && 'âŒ Failed' || 'âž– Skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Container Signing:** ${{ needs.container-signing.result == 'success' && 'âœ… Completed' || needs.container-signing.result == 'failure' && 'âŒ Failed' || 'âž– Skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Detailed audit logs have been preserved for compliance purposes." >> $GITHUB_STEP_SUMMARY